<html>
  <head>
    <title>Angular Best Practices</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="fonts.css" />
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Writing Testable & Shareable Code in Angular


### Xiyang Chen

### rangle.io
---
class: center, middle

# Why?
---
# Motivation #1
- ## I want adequate test coverage for my and my team's codebase so that I can enjoy a quality sleep schedule during the week as well as tranquil and uninterrupted weekends.
---
# Motivation #2
- ## I want my code to be clear, readable and reusable with clearly defined specs, so that my colleages or the suceeding dev team will be appreciative of my work and thus offer to buy me a beer from time to time for saving them time and money.
---
# Motivation #3
- ## I want a testable and maintanable codebase so that my stakeholder's interest is taken care of.
---
# Objectives
- ## Write frontend code that's friendly for Unit & E2E Testing
- ## Keep a maintainable & sharable codebase
---
class: center, middle
# Overall Guidelines
---
# No Big, Giant, Fat Controllers
- ## Wrap business logic into services
- ## Controllers should only be used to set up scope and handle view interactions
---

# Group your code into bundles (modules)
- ### Why? Separating functionalities into modules makes it easier to isolate and troubleshoot errors during testing
- ### Keep modularization horizontal instead of vertical

---
# Vertical Modularization
```
angular.module('app', []);
angular.module('services', []);
angular.module('filters', []);
angular.module('controllers', ['services', 'filters']);
...
```
---
#...better

```
angular.module('app', []);
angular.module('company-api', []);
angular.module('products', ['company-api']);
angular.module('products', ['company-api']);
angular.module('personnels', ['company-api']);
...

```
---
```javascript
angular.module('awsome-app')
  .controller('itemController', ['$scope', '$http',
    function ($scope, $http) {

      function transform (items) { /* ... */ }

      $scope.getItemList = function () {
        //Retrieve list of from remote API server
        $http.get('/api/item').then(
          function success (success) {
            $scope.items = transformItems(res.items);
          },
          function error (error) {
            alert('No item for you!');
          });
      };

      $scope.addItem = function (item) {
        $http({method: 'POST', ...}).then(...);
      };

      $scope.updateItem = function (itemId) {
        $http({method: 'PUT', ...}).then(...)
      };

      /* ... */

  }]);
```
---
```javascript
angular.module('awsome-app')
  .service('itemRetriever', [$q, $http, function ($q) {
    function transform () { ... }
    this.get = function () {
      var deferred = $q.defer();
      $http.get('/api/items').then(function success (res) {
        ...
      });
      return deferred.promise;
    };
  });

  .controller('itemController', ['$scope', itemRetriever
  function ($scope, itemRetriever) {
    itemRetriever.get().then(function (transformedItems) {
      $scope.items = transformedItems;
    });

    $scope.addItem = function (item) {...};

    /* ... */

  }]);
```
---
# All External References Should Come from Dependency Injections
- ## Put or wrap global variable and constants into module(“app”).value() or module().constant()
-- Inject them as needed

```javascript
   angular.module('app')
     .factory('ThirdPartyLib', function ($window) {
       return $window.ThirdPartyLib;
     });

  .service('myService', ['ThirdPartyLib',
    function (ThirdPartyLib) {
      ...
    }]);
```

---
# No DOM Manipulation inside Controllers
* ## Use service and directives instead
---
# Small Controllers, Small Services
* ## Break controllers into smaller sub-controllers if it gets too large
---
# Small Controllers, Small Services
* ## Separation of Concerns & Single Responsibility
* ## Eliminate the word "and" in your service's description
* ## Services should be loosely coupled
---

```javascript
angular.module('app').service('productService',
  ['$http', $cartService, $statsEngine
    function ($http, $theCart, $statsEngine) {
      this.getProduct = function () {...}
      this.updateProduct = function (id, product) {...}
      this.getProductStatistics = function (id) {...}
      this.addProductToCart = function (id) {...}
      ...
  }]);
```
---
```javascript
  angular.module('app')
   .service('productLoader',
     ['$http', function ($http) {
       this.getProduct = function () {...}
       ...
    }]);

    .service('productUpdater',
      ['$http', function ($http) {
        this.purchaseProduct = function () {...}
        ...
     }]);

    .service('productStats',
      ['$http', function ($statEngine) {
        this.getProductStats = function () {...}
        ...
      }]);

```

---
# Use Routes + Resolve Pattern
- ## Available in $routeProvider or AngularUI Router
- ## Define/divide resource loading by routes. Expose state on routes
- ## Good for E2E testing
---
```javascript
angular.module("app")
  .config(["$routeProvider",
    function routeConfig($routeProvider) {
      $routeProvider.
      when("/", {
          controller: "itemController",
          templateUrl: "view/items.html",
          resolve: {
            items: function ($itemLoader, $q) {
              var deferred = $q.defer();
              itemLoader.loadItems().then(
                 function (items) {
                  deferred.resolve(helper);
              });
              return deferred.promise;
            }
          }
      });
  }]);
```
---
```javascript
angular.module("app")
  .controller('itemController', ['products',
    function (products) {
      $scope.products = products;
  }]);
```
---
class: center, middle
# Tips
---
class: center, middle
### Use $window, $location, $interval, instead of window, location, setInterval
So that dependencies are isolated
---
class: center, middle
### Use $log.info(), .debug(), .error(), etc. instead of console.log
So that your tests won't be litered with log messages
---
### angular.copy, angular.extend, angular.forEach
---
class: center, middle
### Use $interval instead of $timeout
So that E2E testing won’t return a timeout error
---
# References

- Angular Best Practices and anti-patterns https://github.com/angular/angular.js/wiki/Best-Practices
- Joe Eames, AngularJS Best Practices, Pluralsight.com
- Miško Hevery, Writing Testable Code, http://googletesting.blogspot.ca/2008/08/by-miko-hevery-so-you-decided-to.html
- Mark Ethan Trostler, Testable JavaScript, O'Reilly Media, Jan 2013

---
# Thank you

- ### Slides: http://github.com/settinghead/angular-best-practices-slides
- ### Or follow me (@settinghead) or @rangle
    </textarea>
    <script src="bower_components/remark/out/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
